jpackage schedules.basictopologicalsort;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.HashMap;
import schedules.activities.Activity;
import schedules.basicconstraints.PrecedenceConstraint;


public class TopologicalSorter{
	public TopologicalSorter(){}

	public ArrayList<Activity> bruteForceSort(HashSet<Activity> activities, HashSet<PrecedenceConstraint> precedenceConstraints){
		HashSet<Activity> activitiesCopy = new HashSet<> ();
		for(Activity act : activities){
			activitiesCopy.add(act);
		}
		ArrayList<Activity> res = new ArrayList<Activity> ();
		while(activitiesCopy.size() != 0){
			Activity avalaibleObject = searchAvalaibleObject(activitiesCopy, res, precedenceConstraints);
			if (avalaibleObject == null){
				return null;
			}
			
			else{
				res.add(avalaibleObject);
				activitiesCopy.remove(avalaibleObject);
			}
		}
		
		return res;
	}
	
	public Activity  searchAvalaibleObject(HashSet<Activity> activities,  ArrayList<Activity> res, HashSet<PrecedenceConstraint> precedenceConstraints){
		for (Activity currentActivity : activities){
			boolean ok = true;
			for (PrecedenceConstraint constraint :  precedenceConstraints){
				if (currentActivity  == constraint.getSecond() && !res.contains(constraint.getFirst())){
					ok = false;
					break;
				}
			}
			if (ok){
				return currentActivity;
			}

		}
	return null;
	}

	public HashMap<Activity, Integer> schedule(HashSet<Activity> activities, HashSet<PrecedenceConstraint> precedenceConstraints, int date){
		HashMap<Activity, Integer> activitiesMap  = new HashMap<> ();
		
		if (bruteForceSort(activities, precedenceConstraints) == null){
			return null;
		}

		else{
			ArrayList<Activity> mesActivites = bruteForceSort(activities, precedenceConstraints); 
			int currentDate = date;
			for(Activity act : mesActivites){
				activitiesMap.put(act, currentDate);
				currentDate += act.getDuration();
			}
		
			return activitiesMap;
		}
	}

	
	


}
